**WORK IN PROGRESS**

# Introduction
Welcome to the section where the first two days of the course will be covered. In the first days, we have explored the RISC-V ISA and the GNU compiler toolchain. We have also learned how to write C code and compile it to RISC-V assembly, how to use the RISC-V ISA simulator to run our code and debug it.

## Compile and execute C code on a RISC-V simulator
We started by writing a simple C program to add numbers from 1 to 9 and print the result:
```c
#include <stdio.h>

int main(){
	int i, sum = 0, n = 9;
	for (i = 1; i <= n; ++i){
	sum += i;
	}
	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
	return 0;
}
```
We can compile the code using the RISC-V compiler toolchain and the -O1 flag:
```bash
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
We can now run the code on the RISC-V ISA simulator:
```bash
spike pk sum1ton.o
```
And we can see inside the compiled code using the objdump tool:
```bash
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
Taking a look at the assembly code, we can notice that our main method is introduced at address 10184 and the code looks like this:
```assembly
0000000000010184 <main>:
   10184:       ff010113                addi    sp,sp,-16
   10188:       00113423                sd      ra,8(sp)
   1018c:       02d00613                li      a2,45
   10190:       00900593                li      a1,9
   10194:       00021537                lui     a0,0x21
   10198:       18050513                addi    a0,a0,384 # 21180 <__clzdi2+0x48>
   1019c:       26c000ef                jal     ra,10408 <printf>
   101a0:       00000513                li      a0,0
   101a4:       00813083                ld      ra,8(sp)
   101a8:       01010113                addi    sp,sp,16
   101ac:       00008067                ret
```
We can see that the instruction addresses increase 4 by 4 and the ttotal number of instructions generated by the -O1 flag is 11. If we use the -Ofast flag we can see that the code has now changed:
```assembly
00000000000100b0 <main>:
   100b0:       00021537                lui     a0,0x21
   100b4:       ff010113                addi    sp,sp,-16
   100b8:       02d00613                li      a2,45
   100bc:       00900593                li      a1,9
   100c0:       18050513                addi    a0,a0,384 # 21180 <__clzdi2+0x48>
   100c4:       00113423                sd      ra,8(sp)
   100c8:       340000ef                jal     ra,10408 <printf>
   100cc:       00813083                ld      ra,8(sp)
   100d0:       00000513                li      a0,0
   100d4:       01010113                addi    sp,sp,16
   100d8:       00008067                ret
```
While I would expect the -Ofast compilation to have a smaller number of instructions, the code has the same number of instructions as the -O1 compilation. We can notice that the memory address of main is different than before, now it is 100b0.

To simulate the program, we use the following command:
```bash
spike pk sum1ton.o
```
To debug it instruction by instruction, we can use the command below:
```bash
spike -d pk sum1ton.o
```
and we can then give the debugger the pc address of the instruction we want to execute:
```bash
until pc 0 100b0
```
This, in case of the -Ofast compilation, will execute the first instruction of the main method. We can then continue executing the code instruction by instruction and see the value of the registers by using:
```bash
reg 0 a0
```
This would show us the value of the a0 register at the current instruction.

## Signed and Unsigned
In this lab, we learn about signed and unsigned variables. An unsigned 64-bit int is represented by the type unsigned long long int and can have a maximum value of $2^{64}-1$. To try and use this type, we can use the following C code:
```c
#include <stdio.h>
#include <math.h>

int main() {
        unsigned long long int max = (long long int) (pow(2,64) -1);
        printf("highest number represented by unsigned long long int is %llu\n", max);
        return 0;
}       
```
Signed 64-bit integers, since they also have to store the sign, can only represent numbers from $-2^{63}$ to $2^{63}-1$. To try and use the long long int type, we can use the following C code:
```c
#include <stdio.h>
#include <math.h>

int main() {
        long long int max = (long long int) (pow(2,63)-1);
	long long int min = (long long int) (pow(2,63)*-1);
        printf("highest number represented by long long int is %lld\n", max);
	printf("lowest number represented by long long int is %lld\n", min);
        return 0;
}
```
