# Introduction
Welcome to the section where the first two days of the course will be covered. In the first days, we have explored the RISC-V ISA and the GNU compiler toolchain. We have also learned how to write C code and compile it to RISC-V assembly, how to use the RISC-V ISA simulator to run our code and debug it.

## Compile and execute C code on a RISC-V simulator
We started by writing a simple C program to add numbers from 1 to 9 and print the result:
```c
#include <stdio.h>

int main(){
	int i, sum = 0, n = 9;
	for (i = 1; i <= n; ++i){
	sum += i;
	}
	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
	return 0;
}
```
We can compile the code using the RISC-V compiler toolchain and the -O1 flag:
```bash
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
We can now run the code on the RISC-V ISA simulator:
```bash
spike pk sum1ton.o
```
And we can see inside the compiled code using the objdump tool:
```bash
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
Taking a look at the assembly code, we can notice that our main method is introduced at address 10184 and the code looks like this:
```assembly
0000000000010184 <main>:
   10184:       ff010113                addi    sp,sp,-16
   10188:       00113423                sd      ra,8(sp)
   1018c:       02d00613                li      a2,45
   10190:       00900593                li      a1,9
   10194:       00021537                lui     a0,0x21
   10198:       18050513                addi    a0,a0,384 # 21180 <__clzdi2+0x48>
   1019c:       26c000ef                jal     ra,10408 <printf>
   101a0:       00000513                li      a0,0
   101a4:       00813083                ld      ra,8(sp)
   101a8:       01010113                addi    sp,sp,16
   101ac:       00008067                ret
```
We can see that the instruction addresses increase 4 by 4 and the ttotal number of instructions generated by the -O1 flag is 11. If we use the -Ofast flag we can see that the code has now changed:
```assembly
00000000000100b0 <main>:
   100b0:       00021537                lui     a0,0x21
   100b4:       ff010113                addi    sp,sp,-16
   100b8:       02d00613                li      a2,45
   100bc:       00900593                li      a1,9
   100c0:       18050513                addi    a0,a0,384 # 21180 <__clzdi2+0x48>
   100c4:       00113423                sd      ra,8(sp)
   100c8:       340000ef                jal     ra,10408 <printf>
   100cc:       00813083                ld      ra,8(sp)
   100d0:       00000513                li      a0,0
   100d4:       01010113                addi    sp,sp,16
   100d8:       00008067                ret
```
While I would expect the -Ofast compilation to have a smaller number of instructions, the code has the same number of instructions as the -O1 compilation. We can notice that the memory address of main is different than before, now it is 100b0.

To simulate the program, we use the following command:
```bash
spike pk sum1ton.o
```
To debug it instruction by instruction, we can use the command below:
```bash
spike -d pk sum1ton.o
```
and we can then give the debugger the pc address of the instruction we want to execute:
```bash
until pc 0 100b0
```
This, in case of the -Ofast compilation, will execute the first instruction of the main method. We can then continue executing the code instruction by instruction and see the value of the registers by using:
```bash
reg 0 a0
```
This would show us the value of the a0 register at the current instruction.

## Signed and Unsigned
In this lab, we learn about signed and unsigned variables. An unsigned 64-bit int is represented by the type unsigned long long int and can have a maximum value of $2^{64}-1$. To try and use this type, we can use the following C code:
```c
#include <stdio.h>
#include <math.h>

int main() {
        unsigned long long int max = (long long int) (pow(2,64) -1);
        printf("highest number represented by unsigned long long int is %llu\n", max);
        return 0;
}       
```
Signed 64-bit integers, since they also have to store the sign, can only represent numbers from $-2^{63}$ to $2^{63}-1$. To try and use the long long int type, we can use the following C code:
```c
#include <stdio.h>
#include <math.h>

int main() {
        long long int max = (long long int) (pow(2,63)-1);
	long long int min = (long long int) (pow(2,63)*-1);
        printf("highest number represented by long long int is %lld\n", max);
	printf("lowest number represented by long long int is %lld\n", min);
        return 0;
}
```

## Lab for ABI (Application Binary Interface) function calls
In this lab, we will integrate assembly code with C code. We will write a C program that calls an assembly function that calculates the sum of the numbers from 1 to 9. The C code is the following:
```c
#include <stdio.h>

extern int load(int x, int y);

int main() {
	int result = 0;
	int count = 9;
	result = load(0x0, count+1);
	printf("Sum of number from 1 to %d is %d\n", count, result);
}
```
The assembly code in the function load is the following:
```assembly
.section .text
.global load
.type load, @function

load:
	add 	a4, a0, zero //Initialize sum register a4 with 0x0
	add 	a2, a0, a1   // store count of 10 in register a2. Register a1 is loaded with 0xa (decimal 10) from main program
	add	a3, a0, zero // initialize intermediate sum register a3 by 0
loop:	add 	a4, a3, a4   // Incremental addition
	addi 	a3, a3, 1    // Increment intermediate register by 1	
	blt 	a3, a2, loop // If a3 is less than a2, branch to label named <loop>
	add	a0, a4, zero // Store final result to register a0 so that it can be read by main program
	ret
```
This time, to compile the code, we have to use the following command:
```bash
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o 1ton_custom.o 1ton_custom.c load.S
```
When we dump the assembly code we can see both the main function and the load function:
```assembly
00000000000100b0 <main>:
   100b0:       ff010113                addi    sp,sp,-16
   100b4:       00a00593                li      a1,10
   100b8:       00000513                li      a0,0
   100bc:       00113423                sd      ra,8(sp)
   100c0:       0fc000ef                jal     ra,101bc <load>
   100c4:       00050613                mv      a2,a0
   100c8:       00021537                lui     a0,0x21
   100cc:       00900593                li      a1,9
   100d0:       1a050513                addi    a0,a0,416 # 211a0 <__clzdi2+0x3c>
   100d4:       360000ef                jal     ra,10434 <printf>
   100d8:       00813083                ld      ra,8(sp)
   100dc:       00000513                li      a0,0
   100e0:       01010113                addi    sp,sp,16
   100e4:       00008067                ret

00000000000101bc <load>:
   101bc:       00050733                add     a4,a0,zero
   101c0:       00b50633                add     a2,a0,a1
   101c4:       000506b3                add     a3,a0,zero

00000000000101c8 <loop>:
   101c8:       00e68733                add     a4,a3,a4
   101cc:       00168693                addi    a3,a3,1
   101d0:       fec6cce3                blt     a3,a2,101c8 <loop>
   101d4:       00070533                add     a0,a4,zero
   101d8:       00008067                ret
```
The main function starts at address 100b0, the load function starts at address 101bc and the loop function is at address 101c8. We can see that the main function calls the load function at address 101bc and then stores the result in register a2. The result is then printed by the printf function.

## Verification flow
After cloning the lab repository:
```bash
git clone https://github.com/kunalg123/riscv_workshop_collaterals.git
```
We will need the following files:
* ```picorv32.v```, a Verilog implementation of a small RISC-V core,
* ```testbench.v```, a testbench for testing the core,
* ```rv32im.sh```, a script that outputs a hex file with the instructions to be executed by the core.

This is the content of the rv32im.sh script:
```bash
riscv64-unknown-elf-gcc -c -mabi=ilp32 -march=rv32im -o 1to9_custom.o 1to9_custom.c 
riscv64-unknown-elf-gcc -c -mabi=ilp32 -march=rv32im -o load.o load.S

riscv64-unknown-elf-gcc -c -mabi=ilp32 -march=rv32im -o syscalls.o syscalls.c
riscv64-unknown-elf-gcc -mabi=ilp32 -march=rv32im -Wl,--gc-sections -o firmware.elf load.o 1to9_custom.o syscalls.o -T riscv.ld -lstdc++
chmod -x firmware.elf
riscv64-unknown-elf-gcc -mabi=ilp32 -march=rv32im -nostdlib -o start.elf start.S -T start.ld -lstdc++
chmod -x start.elf
riscv64-unknown-elf-objcopy -O verilog start.elf start.tmp
riscv64-unknown-elf-objcopy -O verilog firmware.elf firmware.tmp
cat start.tmp firmware.tmp > firmware.hex
python3 hex8tohex32.py firmware.hex > firmware32.hex
rm -f start.tmp firmware.tmp
iverilog -o testbench.vvp testbench.v picorv32.v
chmod -x testbench.vvp
vvp -N testbench.vvp
```
The script first compiles the C and assembly code to object files, then it links them to create the firmware.elf file. It then compiles the start.S file and links it to create the start.elf file. The start.elf and firmware.elf files are then converted to hex files and concatenated to create the firmware.hex file. The firmware.hex file is then converted to a 32-bit hex file and the testbench is compiled and executed using iverilog.

The result of the testbench execution is the following:
```bash
vsduser@vsduser-VirtualBox:~/riscv_workshop_collaterals/labs$ ./rv32im.sh 
Sum of number from 1 to 2 is 3
TRAP
```

In this part of the course we have learned the absolute basics of RISC-V ABI, how to compile and execute C code on a RISC-V simulator, how to write assembly code and integrate it with C code and how to verify the functionality of a RISC-V core using a testbench.